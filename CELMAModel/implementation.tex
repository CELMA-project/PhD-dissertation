\section{Implementation}
\label{sec:implementation}
This section describes the details in the numerical implementation of the CELMA
code

\subsection{Obtaining \texorpdfstring{$\phi$}{the potential}}
%
We observe the dependency of $\phi$ in equation (\ref{eq:cyto_dens}) -
(\ref{eq:cyto_vortD_evolution}), but that $\phi$ is not described by a
initial boundary value problem equation. Instead, we must find alternative ways
of extracting $\phi$. We will in the following discuss three ways of doing so.
Two of the methods discussed finds $\phi$ by inversion of the non-linear
boundary value problem $\Om^D = \div\L(n\grad_\perp\phi\R)$ for $\phi$ for
every time step, and one finds $\phi$ by imposing a constraint on the system of
equations.

\subsubsection{As a matrix inversion problem}
%
The problem of obtaining $\phi$ can be posed as a matrix problem
$A\ve{x}=\ve{b}$, where $\ve{x}$ is an array of all the spatial values of
$\phi$ ordered in some way, and $\ve{b}$ is an array of all the spatial values
of $\Omega^D$ ordered in the same way. Since we are working in an orthogonal
coordinate system, we have that $\Om^D = \div\L(n\grad_\perp\phi\R) =
\grad_\perp\cdot\L(n\grad_\perp\phi\R)$, as no basis vector parallel to the
magnetic field can be obtained from taking the derivative of the vector
$n\grad_\perp\phi$, which has only perpendicular components. Thus, in our case,
we can solve the $A\ve{x}=\ve{b}$ system for each plane perpendicular to the
magnetic field. That is, our matrix $A$ would be a $n_x \times n_y$ matrix,
where $n_x$ and $n_y$ is the number of points for the two perpendicular
directions
%
\footnote{
Note that in the BOUT++ implementation, $y$ is chosen as the direction parallel
to the magnetic field.  due to historical reasons, and $n_y$ would be named
$n_z$ in BOUT++ convention.  In order not to confuse readers unfamiliar with
BOUT++, $z$ is chosen as the coordinate along the magnetic field unless other
is specified.
}%
%
. We note that if $\div\L(n\grad_\perp\phi\R)$ were not purely
perpendicular, we would have to solve $A\ve{x}=\ve{b}$ for the whole domain. In
other words, the size of matrix $A$ would be $n_x \times n_y \times n_z$, and
would be considerably harder to solve numerically.

As noted in \cite{Wiesenberger2014Phd} (in the case where $P=1$, that is, in
the finite difference case), the discretization of the elliptic equation
$\div\L(n\grad_\perp\phi\R)=\Om^D$ can be formulated in a symmetric manner,
when special care is taken at the boundary.

Solving for the ghost-point, meaning that the ghost-point would be one of the
unknown in $A\ve{x}=\ve{b}$, would break the symmetry. Instead, one must
reformulate the boundary condition in a way such that it becomes an equation
for the ghost point. The equation of the ghost point can then be substituted
into the equations for the first/last inner point (the point just before the
boundary) and thus effictively eliminating the ghost point from the set of
equations.

To exemplify, consider a second order dirichlet boundary condition with the
boundary half between grid points for the equation $\partial_x^2 f = b$, where
$f_{-1}$ denotes the value at the ghost point, $f_{\text{BC}}$ denotes the
value at the boundary and $f_{1}$ denotes the value at the first inner ghost
point. The boundary condition can now be written
$\frac{f_{-1}+f_{1}}{2}=f_{\text{BC}}$, and the equation for the first inner
point could be written $\frac{f_{-1}+2f{1}+f_{2}}{(\Delta x)^2}=b_1$. This
would lead to the equation system
%
\begin{align*}
    A\cdot\ve{f}=&\ve{b}\\
    %
    \frac{1}{(\Delta x)^2}
    \begin{bmatrix}
        (\Delta x)^2\frac{1}{2} & (\Delta x)^2\frac{1}{2} & 0 & 0 & \ldots\\
        1                       & 2                       & 1 & 0 & \ldots\\
        0                       & 1                       & 2 & 1 & \ldots\\
        \vdots                  & \vdots              &\vdots&\vdots&\ddots\\
    \end{bmatrix}
    \cdot
    \begin{bmatrix}
        f_{-1}\\
        f_{1}\\
        f_{2}\\
        f_{3}\\
        \vdots
    \end{bmatrix}
    =&
    \begin{bmatrix}
        f_{\text{BC}}\\
        b_{1}\\
        b_{2}\\
        b_{3}\\
        \vdots
    \end{bmatrix}
\end{align*}
%
which is clearly non-symmetric.

The symmetric way to implement this would be to write
$f_{-1}=2f_{\text{BC}}-f_{1}$ for the boundary condition, and substitute this
into the 2nd order finite difference equation for the first inner ghost point.
This gives
%
\begin{align*}
    \frac{f_{-1}+2f{1}+f_{2}}{(\Delta x)^2}&=b_1\\
    \frac{2f_{\text{BC}}-f_{1}+2f{1}+f_{2}}{(\Delta x)^2}&=b_1\\
    \frac{f{1}+f_{2}}{(\Delta x)^2}&=b_1 - \frac{2f_{\text{BC}}}{(\Delta x)^2}
\end{align*}
%
This would give
%
\begin{align*}
    A\cdot\ve{f}=&\ve{b}\\
    %
    \frac{1}{(\Delta x)^2}
    \begin{bmatrix}
        1                       & 1                       & 0 & 0 & \ldots\\
        1                       & 2                       & 1 & 0 & \ldots\\
        0                       & 1                       & 2 & 1 & \ldots\\
        \vdots                  & \vdots              &\vdots&\vdots&\ddots\\
    \end{bmatrix}
    \cdot
    \begin{bmatrix}
        f_{1}\\
        f_{2}\\
        f_{3}\\
        \vdots
    \end{bmatrix}
    =&
    \begin{bmatrix}
        b_{1} - \frac{2f_{\text{BC}}}{(\Delta x)^2}\\
        b_{2}\\
        b_{3}\\
        \vdots
    \end{bmatrix}
\end{align*}
%
which is symmetric. Although difficult, one can show that the non-linear
elliptic equation in its symmetric form can be singular positive definite and
thus be solved using the conjugate gradient method.

\subsubsection{The Naulin solver}
%





%
%FIXME:
FIXME: Rewrite this as implementation has changed

%
We will solve the derived equations using the BOUT++ framework, using the field
aligned discretization operators. We note that we are not working in a field
aligned coordinate system, but in a cylindrical coordinate system described in
appendix \ref{app:cylcoord}. The difference between the field aligned and our
cylindrical coordinate system lays in the value of $B$, where $B_\text{Field
    aligned}=\frac{1}{\rho}$, whereas $B_\text{Our system}=\text{Constant}$.
The only place one needs to take care about this is when using the Poisson
brackets to calculate the $\ve{E}\times \ve{B}$ advection, which will be
discussed in the next section.

\subsection{\texorpdfstring{$\ve{E}\times \ve{B}$}{ExB} advection}
\label{sec:ExBadv}
% FIXME:
FIXME: See Derivation of pure solenoid field in the coordinates manual: We are
interested in the pure solenoidal field. What about the strength of the field
when normalizing? Metric of Clebsch and cylinder coincides, but BOUT++ return
Arakawa in Clebsch. Note that our field strength is only appearing in units
like $\rho_s$.

FIXME: Must also be fixed in equations above. NOTE: Volker's implementation
also works like that

As described in appendix \ref{app:poisson}, we can write the
$\ve{E}\times\ve{B}$ advection in a field aligned coordinate system as
%
\begin{align}
    \ve{u}_E\cdot\nabla
    = -\frac{\nabla\phi\times\ve{b}}{B}\cdot\nabla
    = \{\phi, \cdot\}_{\theta,\rho}
    = \partial_\theta\phi\partial_\rho - \partial_\rho\phi\partial_\theta
    \label{eq:non_norm_adv}
\end{align}
%
Nevertheless, we are using a cylindrical coordinate system, where $B$ is
constant.  Since $B$ is constant,
we can choose $B_0$ in the normalization in such a way that $\widetilde{B}=1$.
Accordingly, the derivation of the normalized $\ve{E}\times \ve{B}$ advection
follows that of appendix \ref{app:poisson} with the only difference that we
multiply the equations with
$B_\text{Field aligned}=\frac{1}{J}\sqrt{g_{zz}}=\frac{1}{J}=\frac{1}{\rho}$.
This means that in normalized units (dropping the subscript on the Poisson
brackets from now in) gives
%
\begin{align*}
    \ve{u}_E\cdot\nabla = \frac{1}{J}\{\phi, \cdot\}
\end{align*}


\subsection{The divergence terms}
%
The four divergence terms in equation (\ref{eq:normalized_non_boussinesq})
cannot be implemented directly into BOUT++. The reason for this is that there
are not implemented own finite difference (FD) operators for these terms in
full. Neither can one put together the different FD operators composing the
full terms in order to build these full term FD operators, as some of the
boundary conditions will remain unspecified.

To exemplify this, consider a FD operator such as $\partial^{\text{FD}}_i$
(where the $^\text{FD}$ denotes a discretized FD operator) working on $f$ to
yield $g$ (that is $g = \partial^{\text{FD}}_if$). $g$ will be calculated in
all inner points by using the information of the boundary condition of $f$.
However, the information of the boundary conditions of $g$ will remain
unspecified after this operation.  This means that operations such as
$\partial^{\text{FD}}_j g = \partial_j^{\text{FD}}\L(\partial_i^{\text{FD}}
f\R)$ is not possible to perform as the boundary condition of $g$ is
unspecified.

There are at least two ways to work around this problem. Firstly, one could use
combined operators such as $\L(\parti{^2}{_j\partial_i}\R)^\text{FD}f$.  Given
that we are using the appropriate finite difference approximation (FDA), we
would not run into the trouble of the "missing" boundary condition as it does
not go through the immediate step of calculating $g$.  However, rewriting the
divergence terms in such a way that we will only make use of FDAs which does
not give troubles of "missing" boundaries yields many terms, and implementing
all the resulting terms can be error prone as there are so many of them. Also,
one should not neglect the possibility of making an calculation mistake along
the way.

Secondly, one could calculate the boundary condition for $g$ by evaluating the
derivative of the $f$ on the boundary, and apply it to $g$ before calculating
$\partial^{\text{FD}}_j$. As this method is less error prone than the previous,
we will pursue this method.

\subsubsection{Writing out the vectors in the divergence terms}
% FIXME: Rewrite what BC's you need. Should be properly written in the code
Before we proceed any further, we will write out the vectors in the divergence
terms in equation (\ref{eq:normalized_non_boussinesq}). First we consider
%
\begin{align*}
    \ve{u}_E\cdot\grad\L[n\frac{\grad_\perp\phi}{B}\R]
    =&
    \frac{1}{J}
    \L\{\phi, n\frac{\grad_\perp\phi}{B}\R\}
    \\
    =&
    \frac{1}{J}\L(
    \partial_\theta \phi \partial_\rho \L[n\frac{\grad_\perp\phi}{B}\R]
    -
    \partial_\rho \phi \partial_\theta \L[n\frac{\grad_\perp\phi}{B}\R]
    \R)
    \\
    =&
    \frac{1}{J}\L(
    \partial_\theta \phi \partial_\rho
    \L[\ve{e}^\rho n\frac{\partial_\rho \phi}{B}
    + \ve{e}^\theta n\frac{\partial_\theta \phi}{B}\R]
    -
    \partial_\rho \phi \partial_\theta
    \L[\ve{e}^\rho n\frac{\partial_\rho \phi}{B}
    + \ve{e}^\theta n\frac{\partial_\theta \phi}{B}\R]
    \R)
    \\
    =&
    \frac{1}{J}\L(
    \partial_\theta \phi \partial_\rho
    \L[ \ve{e}^\rho n\frac{\partial_\rho \phi}{B} \R]
    +
    \partial_\theta \phi \partial_\rho
    \L[ \ve{e}^\theta n\frac{\partial_\theta \phi}{B} \R]
    -
    \partial_\rho \phi \partial_\theta
    \L[ \ve{e}^\rho n\frac{\partial_\rho \phi}{B} \R]
    -
    \partial_\rho \phi \partial_\theta
    \L[ \ve{e}^\theta n\frac{\partial_\theta \phi}{B} \R]
    \R)
    \\
    =&
    \frac{1}{J}\L(
    \ve{e}^\rho \partial_\theta \phi \partial_\rho
    \L[ n\frac{\partial_\rho \phi}{B} \R]
    +
    n\frac{\partial_\rho \phi}{B}
    \partial_\theta \phi \partial_\rho \ve{e}^\rho
    +
    \ve{e}^\theta \partial_\theta \phi \partial_\rho
    \L[ n\frac{\partial_\theta \phi}{B} \R]
    +
    n\frac{\partial_\theta \phi}{B}
    \partial_\theta \phi \partial_\rho \ve{e}^\theta
    \R.
    \\&
    \L.
    -
    \ve{e}^\rho \partial_\rho \phi \partial_\theta
    \L[ n\frac{\partial_\rho \phi}{B} \R]
    -
    n\frac{\partial_\rho \phi}{B}
    \partial_\rho \phi \partial_\theta \ve{e}^\rho
    -
    \ve{e}^\theta \partial_\rho \phi \partial_\theta
    \L[ n\frac{\partial_\theta \phi}{B} \R]
    -
    n\frac{\partial_\theta \phi}{B}
    \partial_\rho \phi \partial_\theta \ve{e}^\theta
    \R)
    \\
    =&
    \frac{1}{J}\L(
    \ve{e}^\rho \partial_\theta \phi \partial_\rho
    \L[ n\frac{\partial_\rho \phi}{B} \R]
    +
    n\frac{\partial_\rho \phi}{B}
    \partial_\theta \phi \L[0\R]
    +
    \ve{e}^\theta \partial_\theta \phi \partial_\rho
    \L[ n\frac{\partial_\theta \phi}{B} \R]
    +
    n\frac{\partial_\theta \phi}{B}
    \partial_\theta \phi
    \L[ -\frac{1}{\rho} \ve{e}^\theta \R]
    \R.
    \\&
    \L.
    -
    \ve{e}^\rho \partial_\rho \phi \partial_\theta
    \L[ n\frac{\partial_\rho \phi}{B} \R]
    -
    n\frac{\partial_\rho \phi}{B}
    \partial_\rho \phi
    \L[\rho \ve{e}^\theta\R]
    -
    \ve{e}^\theta \partial_\rho \phi \partial_\theta
    \L[ n\frac{\partial_\theta \phi}{B} \R]
    -
    n\frac{\partial_\theta \phi}{B}
    \partial_\rho \phi
    \L[ -\frac{1}{\rho} \ve{e}^\rho \R]
    \R)
    \\
    =&
    \ve{e}^\rho
    \frac{1}{J}\L(
    \partial_\theta \phi \partial_\rho  \L[ n\frac{\partial_\rho \phi}{B} \R]
    -\partial_\rho \phi \partial_\theta \L[ n\frac{\partial_\rho \phi}{B} \R]
    + \frac{1}{\rho}n\frac{\partial_\theta \phi}{B} \partial_\rho \phi
    \R)
    \\&
    +
    \ve{e}^\theta
    \frac{1}{J}\L(
    \partial_\theta \phi \partial_\rho   \L[ n\frac{\partial_\theta \phi}{B} \R]
    - \partial_\rho \phi \partial_\theta \L[ n\frac{\partial_\theta \phi}{B} \R]
    - \frac{1}{\rho} n\frac{\partial_\theta \phi}{B} \partial_\theta \phi
    - \rho n\frac{\partial_\rho \phi}{B} \partial_\rho \phi
    \R)
    \\
    =&
    \ve{e}^\rho
    \frac{1}{J} \L(
    \L\{ \phi, n\frac{\partial_\rho \phi}{B} \R\}
    + \frac{1}{J} n\frac{\partial_\theta \phi}{B} \partial_\rho \phi
    \R)
    +
    \ve{e}^\theta
    \frac{1}{J}\L(
    \L\{ \phi, n\frac{\partial_\theta \phi}{B} \R\}
    - \frac{1}{J} n\frac{\partial_\theta \phi}{B} \partial_\theta \phi
    - Jn\frac{\partial_\rho \phi}{B} \partial_\rho \phi
    \R)
    \numberthis
    \label{eq:vec_adv_expanded}
\end{align*}
%
In order to implement equation (\ref{eq:vec_adv_expanded}) using FDAs as
described above, we see that we need to specify the $\rho$ boundaries (see next
section) of $n \partial_\rho \phi$ and $n \partial_\theta \phi$ in order to use
the Poisson bracket. Note that we do not need to calculate any $\theta$
boundaries, as the $\theta$-direction is periodical.

We also need to figure out what boundaries we need to specify on the terms of
equation (\ref{eq:vec_adv_expanded}) in order to take the divergence of this
equation, using a FDA. The divergence in general coordinates is given in
equation (2.6.39) in
% FIXME: Fix this cite
\cite{Dhaeseleer1991book}, and which reads
%
\begin{align}
    \div\ve{A}=\frac{1}{J}\partial_i\L(JA^i\R)
    \label{eq:div}
\end{align}
%
The orthogonality of the cylindrical coordinate system ensures that
$A_i\ve{e}^i=A_i g^{ii}\ve{e}_i$. Thus, from equation (\ref{eq:div}) we see that the
divergence operator will take the $i$ derivatives of the $i$ terms in equation
(\ref{eq:vec_adv_expanded}). From this we can conclude that we need to
specify the $\rho$ boundaries of $ \frac{1}{J} \L\{ \phi, n\frac{\partial_\rho
    \phi}{B} \R\} $ and $ \frac{1}{J^2} n\frac{\partial_\theta \phi}{B}
\partial_\rho \phi $ before taking the divergence.

Again, we need not to specify any $\theta$ boundaries as $\theta$ is
periodical. Further on, as the $\ve{e}^z$ component of equation
(\ref{eq:vec_adv_expanded}) is $0$, the divergence of equation
(\ref{eq:vec_adv_expanded}) will yield no parallel derivatives, and no $z$
boundary conditions need to be set.

Secondly we have
%
\begin{align*}
    u_{i,\|}\partial_\|\L(\frac{\grad_\perp \phi}{B}n\R)
    =&
    u_{i,\|}\partial_\|
    \L( \ve{e}^\rho\frac{\partial_\rho \phi}{B}n
    + \ve{e}^\theta\frac{\partial_\theta \phi}{B}n \R)
    \note{$\partial_z \ve{e}^i=0$}
    \\
    =&
    \ve{e}^\rho u_{i,\|}\partial_\|\L( \frac{\partial_\rho \phi}{B}n \R)
    + \ve{e}^\theta u_{i,\|}\partial_\|\L( \frac{\partial_\theta \phi}{B}n\R)
    \numberthis
    \label{eq:par_vec_adv_expanded}
\end{align*}
%
where we have to set the $z$ boundaries of $\frac{\partial_\rho \phi}{B}n$
and $\frac{\partial_\theta \phi}{B}n$ in order to calculate the parallel
derivatives of equation (\ref{eq:par_vec_adv_expanded}) using a FDA.

Following the discussion above, we need to specify the $\rho$ boundaries of
$ u_{i,\|}\partial_\| \frac{\partial_\rho \phi}{B}n $ in order to take the
divergence of equation (\ref{eq:par_vec_adv_expanded}) using a FDA.

Thirdly, we have
%
\begin{align*}
    \frac{\grad_\perp \phi}{B}\L(S_n - n\partial_\|u_{i,\|}\R)
    =&
    \ve{e}^\rho\frac{\partial_\rho \phi}{B}\L(S_n - n\partial_\|u_{i,\|}\R)
    +\ve{e}^\theta\frac{\partial_\theta \phi}{B}\L(S_n - n\partial_\|u_{i,\|}\R)
    \numberthis
    \label{eq:i_cont_expanded}
\end{align*}
%
This means that we need to find the $\rho$ boundaries of
$\frac{\partial_\rho \phi}{B}S_n$
and
$\frac{\partial_\rho \phi}{B}n\partial_\|u_{i,\|}$
before taking the divergence of equation (\ref{eq:i_cont_expanded}) using a FDA.

Finally we have
%
\begin{align}
 S_n \frac{ \grad_\perp \phi }{B}
 &=
 \ve{e}^\rho S_n \frac{ \partial_\rho \phi }{B}
 +\ve{e}^\theta S_n \frac{ \partial_\theta \phi }{B}
 \label{eq:div_S}
\end{align}
%
and we see that we need to specify the $\rho$ boundary condition of
$ \ve{e}^\rho S_n \frac{ \partial_\rho \phi }{B}$ in order to find the
divergence of equation (\ref{eq:div_S}) using a FDA.

\subsubsection{Specification of BC of the intermediate fields}
%
% FIXME: Rewrite this as it is complicatedly written
In our implementation we will place the boundaries half between the grid
points. Assume now that we have our original field $f$ which the know the
boundary condition for, and we wish to evaluate the derivative at the boundary
so that $g_{\text{B}}=\partial^{\text{FD}}f\bigg|_\text{boundary}$, where
$g_{\text{B}}$ denotes the value on the boundary of $g$. Approximating
$g_{\text{B}}$ with a second order centred FDA yields
%
\begin{align*}
    g_{\text{B}} \simeq \frac{f_\text{GP} - f_{\text{LIP}}}{h}
\end{align*}
%
where $f_\text{GP}$ denotes the ghost point of $f$ located an additional grid
space distance $h$ from $f_{\text{LIP}}$, which is the last inner grid point of
$f$.

% See
% BOUT-projects/cylinder_tests/own_diffusion_python/boundary_polynomial
From $g_{\text{B}}$ we can now use a Newton polynomial to extrapolate the
value of the rightmost ghost point of $g$. The Newton polynomial reads
%
\begin{align}
    p_N(x)=a_0+\sum_{i=1}^Na_i\prod_{j=0}^{i-1}(x-x_j)
    \label{eq:new_pol}
\end{align}
%
the coefficients of this polynomial can be found by solving the following set
of equation up to order $N$ for the unknown coefficients
%
\begin{equation}
    \begin{aligned}
        g(x_0)=&a_0\\
        g(x_1)=&a_0+a_1(x_1-x_0)\\
        g(x_2)=&a_0+a_1(x_2-x_0) + a_2(x_2-x_0)(x_2-x_1)\\
        \vdots&
        \label{eq:divdiffsys}
    \end{aligned}
\end{equation}
%
which can be solved easily using Newton's divided differences.
We would like to use a fourth order polynomial (standard order used when
setting boundaries in BOUT++) to determine the value in at the ghost point,
using information from the three preceding grid points and the value at the
boundary.

In other words, we let
\begin{align*}
x_i =
\{x_{\text{GP}-3}, x_{\text{GP}-2}, x_{\text{GP}-1}, x_\text{GP}\}=
\{x_{\text{GP}-3}, x_{\text{GP}-3}+h, x_{\text{GP}-3}+2h, x_{\text{GP}-3}+3h\}
\end{align*}
%
be the four rightmost grid points (including the ghost point $\text{GP}$). We
use the function values in these points to solve the equation system
(\ref{eq:divdiffsys}) (by, for example, using the recursive divided differences
formula), and insert them into the fourth order Newton polynomial of equation
(\ref{eq:new_pol}). If we evaluate this in
$x=x_\text{B}=x_{\text{GP}-1} +\frac{h}{2}$, we find that
%
\begin{align*}
    g_\text{GP} =
    -\frac{1}{5}g(x_{\text{GP}-3})
    + g(x_{\text{GP}-2})
    -3g(x_{\text{GP}-1})
    +\frac{16}{5}g_{\text{B}}
\end{align*}
%
Notice how $x_{\text{GP}-3}$ got cancelled in the equation system
(\ref{eq:divdiffsys}), and how $h$ got cancelled through the divided differences.

Needless to say, if we need the ghost point of a composite field, let's $e\cdot
g$, in order to calculate $\partial_i^{\text{FD}} \L(e\cdot g\R)$, we can
simply multiply the two ghost points together in order to find the composite
ghost point, that is $\L(e \cdot g\R)_\text{GP} = e_\text{GP}\cdot g_\text{GP}$.


\subsection{Finding the potential}
The observant reader may have noticed that we do not evolve the potential $\phi$
in time, and thus need another way of knowing $\phi$ at each time step. As we
know that
%
\begin{align*}
    \Om^D = \div\L(n\frac{\grad_\perp\phi}{B}\R)
    = n\div\L(\frac{\grad_\perp\phi}{B}\R) +
    \frac{\grad_\perp\phi}{B}\cdot\grad n
    = n\frac{\grad_\perp^2\phi}{B} +
    \grad n\cdot\frac{\grad_\perp\phi}{B}
    = n\frac{\grad_\perp^2\phi}{B} +
    \grad_\perp n\cdot\frac{\grad_\perp\phi}{B}
\end{align*}
%
the current time step $\Om^D$ can be solved to find $\phi$. From that we find
that
%
\begin{align*}
    \Om^D =& n\frac{\grad_\perp^2\phi}{B} +
    \grad_\perp n\cdot\frac{\grad_\perp\phi}{B}
    \\
    \frac{\Om^D}{n} =& \Om +
    \frac{1}{n}\grad_\perp n\cdot\frac{\grad_\perp\phi}{B}
    \\
    \Om =& \frac{\Om^D}{n} -
    \frac{1}{n}\grad_\perp n\cdot\frac{\grad_\perp\phi}{B}
\end{align*}


\subsection{Artificial viscosity}\label{sec:art_visc}
%
In the derivation we have neglected terms which is of order lower than first
order, as these terms are believed to have negligible contribution on the
overall set of equation. One of the drawbacks is, however, that we also have
neglected viscous terms which will dampen small scales in the system. Thus,
if we no not re-introduce some dissipation for numerical purposes, energy is
going to build-up on small scales, and would in the end make the simulation
crash.
%FIXME: Add cite to Phillips instability if applicable

Therefore, we add a dissipation on the form
%
\begin{align*}
    D_{f, \|, \text{art}} \nabla_{\|}^2 f
    + D_{f, \perp, \text{art}} \grad_\perp^2 f
    &=
    D_{f, \|, \text{art}} \div \L(\ve{b}\ve{b}\cdot\grad\R) f
    + D_{f, \perp, \text{art}} \grad_\perp^2 f
    \note{$\partial_i \ve{b} = 0$}
    \\
    %
    &=
    D_{f, \|, \text{art}} \ve{b}\cdot\grad \L(\ve{b}\cdot\grad\R) f
    + D_{f, \perp, \text{art}} \grad_\perp^2 f
    \\
    %
    &=
    D_{f, \|, \text{art}} \partial_\|^2 f
    + D_{f, \perp, \text{art}} \grad_\perp^2 f
    \numberthis
    \label{eq:art_vort}
\end{align*}
%
by exchanging $\div \te{\pi}$ in equation (\ref{fluideq:mom}) with equation
(\ref{eq:art_vort}). This is a somewhat crude approximation, but serves as a
good first approximation. In the non-normalized set of equations the $D$
coefficients would have the units of dynamical viscosity, and would be
normalized by
\\
%
\begin{minipage}{0.4\textwidth}
\begin{empheq}[box={\tcbhighmath[colback=yellow!5!white]}]{align*}
    &    D_{f, \text{art}}  = \wt{D}_{f, \text{art}}m_\a n_0 \rho_s c_s&
\end{empheq}
\end{minipage}
\hfill
\begin{minipage}{0.4\textwidth}
\begin{empheq}[box={\tcbhighmath[colback=yellow!5!white]}]{align*}
    &\wt{D}_{f, \text{art}}  =  \frac{D_{f, \text{art}}}{m_\a n_0 \rho_s c_s}&
\end{empheq}
\end{minipage}
\vspace{0.5cm}
\\
%
We notice that when using equation (\ref{fluideq:mom}) in the derivations,
division by $n$ on the RHS of the equations occurs in the density equation and
the parallel momentum equations, but not in the vorticity equation. The
artificial viscosity in the density is not divided by $n$ as $\frac{1}{n}\grad
n = \ln(n)$.



\subsection{BC for Laplace inversion using FFT}
%
% FIXME:
Write me
